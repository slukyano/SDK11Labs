/****************************************************************************

    i2c.c - простейший драйвер I2C
            для учебного стенда SDK-1.1

    (C) i2c.c, Ключев А.О.  2007 г.

Это свободная программа; вы можете повторно распространять ее и/или
модифицировать ее в соответствии с Универсальной Общественной
Лицензией GNU, опубликованной Фондом Свободного ПО; либо версии 2,
либо (по вашему выбору) любой более поздней версии.

Эта программа распространяется в надежде, что она будет полезной,
но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемых гарантий
КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ.  Для
получения подробных сведений смотрите Универсальную Общественную
Лицензию GNU.

Вы должны были получить копию Универсальной Общественной Лицензии
GNU вместе с этой программой; если нет, напишите по адресу: Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA

----------------------------------------------------------------------------
Россия, Санкт-Петербург, кафедра вычислительной техники СПбГУИТМО 
e-mail: kluchev@d1.ifmo.ru

****************************************************************************/

#include "aduc812.h"
#include "i2c.h"

/*----------------------------------------------------------------------------
                    Функции
 -----------------------------------------------------------------------------*/

/**----------------------------------------------------------------------------
                        delay()
-------------------------------------------------------------------------------
Задержка на время порядка 25 мкс.

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
static void delay( void )
{
char ch = 0;

    while( ch++ < 2 );
}

/**----------------------------------------------------------------------------
                        send_byte()
-------------------------------------------------------------------------------
Посылка по I2C байта (8 бит) и ожидание подтверждения (acknowledge).

Вход:       uchar ch - байт, который нужно послать.
Выход:      нет
Результат:  0 - подтверждение (acknowledge) получено
            1 - не было подтверждения
----------------------------------------------------------------------------- */
static __bit send_byte( unsigned char ch ) //Returns ack (0 = acknowledged)
{
char i;
__bit ack;

    MDE = 1;//Output
    MCO = 0;

    for( i = 0 ; i < 8; i++, ch <<= 1 )
    {
        MDO = ( ch & 0x80 ) ? 1 : 0 ;
        MCO = 1;

        delay();

        MCO = 0;
    }

    MDE = 0;//Input
    MCO = 1;

    delay();

    ack = MDI;
    MCO = 0;
    return ack;
}

/**----------------------------------------------------------------------------
                        start()
-------------------------------------------------------------------------------
Установка состояния Start интерфейса i2c.

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
static void start(void)
{
    MDE = 1;//Output
    MDO = 1;
    MCO = 1;

    delay();

    MDO = 0;

    delay();

    MCO = 0;
}

/**----------------------------------------------------------------------------
                        stop()
-------------------------------------------------------------------------------
Установка состояния Stop интерфейса i2c.

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
static void stop(void)
{
    MDE = 1; //Output
    MCO = 0;
    MDO = 0;
    MCO = 1;

    delay();

    MDO = 1;

    delay();

    MDE = 0; //Input (release line)
}


/**----------------------------------------------------------------------------
                        begin()
-------------------------------------------------------------------------------
Начало сессии на интерфейсе i2c (Start + посылка i2c-адреса slave-устройства).

Вход:       uchar addr - i2c-адрес slave-устройства 
Выход:      нет
Результат:  0 - устройство откликнулось (получено acknowledge)
            1 - устройство не откликнулось
----------------------------------------------------------------------------- */

static __bit begin( unsigned char addr )//Returns ack (0 = acknowledged)
{
    start();

    return send_byte( addr );
}

/**----------------------------------------------------------------------------
                        Ack()
-------------------------------------------------------------------------------
Посылка подтверждения (acknowledge) устройству.

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
static void ack( void )//Sends ack
{
    MDE = 1; //Output
    MCO = 0;
    MDO = 0;
    MCO = 1;

    delay();

    MCO = 0;
}

/**----------------------------------------------------------------------------
                        Nack()
-------------------------------------------------------------------------------
Посылка "неподтверждения" (not acknowledged) устройству.

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */
static void nack(void) //Sends NAck
{
    MDE = 1;
    MCO = 0;
    MDO = 1;
    MCO = 1;

    delay();

    MCO = 0;
}

/**----------------------------------------------------------------------------
                        get_ack()
-------------------------------------------------------------------------------
Проверка на готовность slave-устройства к обмену (начало + получение отклика +
завершение сессии)

Вход:       нет
Выход:      нет
Результат:  нет
----------------------------------------------------------------------------- */

__bit get_ack( unsigned char address ) //Returns 1 if there was an ACK
{
    I2CM = 1; //I2C Master mode

    if( begin( address & 0xFE ) ) 
    { 
        stop(); 
        return 0;
    }

    stop();

    return 1;
}


/**----------------------------------------------------------------------------
                        recv_byte()
-------------------------------------------------------------------------------
Получение 8 бит с шины данных i2c без подтверждения или неподтверждения приема.

Вход:       нет
Выход:      нет
Результат:  принятые 8 бит.
----------------------------------------------------------------------------- */
unsigned char recv_byte(void)
{
char i;
unsigned char ch = 0;

    MDE = 0; //Input
    MCO = 0;

    for( i = 0; i < 8; i++ )
    {
        ch  <<= 1;
        MCO   = 1;

        delay();

        ch   |= MDI;

        MCO   = 0;
    }

    return ch;
}

/**----------------------------------------------------------------------------
                        receive_block()
-------------------------------------------------------------------------------
Получение блока данных от i2c-устройства с 8-разрядным внутренним адресным 
пространством. Принятый блок помещается в область памяти __xdata.

Вход:       uchar address - I2C-адрес устройства;
            uchar addr - адрес во внутреннем адресном пространстве устройства;
            uchar *block - адрес в области __xdata, куда будет помещен принятый
                блок данных;
            uchar len - длина принимаемого блока.

Выход:      нет
Результат:  0 - успешно;
            1 - устройство не откликается.
----------------------------------------------------------------------------- */
__bit receive_block(unsigned char address, unsigned char addr, unsigned char __xdata * block,unsigned char len)
{ //addr - address in target
unsigned char i, ch;

    I2CM    = 1;                    // I2C Master mode
    address = ( address & 0xFE );   // Write

    if( begin( address ) ) 
    {
        stop();
        return 1;
    }   //Error - No ACK

    if( send_byte( addr ) )
    {
        stop();
        return 1;
    }

    delay();
    delay();

    address |= 1;  //Read

    if( begin( address ) ) 
    {
        stop();
        return 1;
    }

    delay();

    if( len-1 )
    {
        for( i = 0; i< ( len - 1 ) ;i++)
        {
            ch = recv_byte();
            ack();

            *block++ = ch;
        }
    }

    ch = recv_byte();
    nack();

    *block = ch;
    stop();

    return 0;
}

/**----------------------------------------------------------------------------
                        send_block()
-------------------------------------------------------------------------------
Запись блока данных во внутреннюю память i2c-устройства с 8-разрядным адресным 
пространством. 

Вход:       uchar address - I2C-адрес устройства;
            uchar addr - адрес во внутреннем адресном пространстве устройства,
                куда будет помещен блок;
            uchar *block - адрес в области __xdata, где располагаются данные для 
                пересылки;
            uchar len - длина записываемого блока.

Выход:      нет
Результат:  0 - успешно;
            1 - устройство не откликается.
----------------------------------------------------------------------------- */
__bit transmit_block(unsigned char address, unsigned char addr, unsigned char __xdata * block,unsigned char len)
{ //addr - address in target
unsigned char ch, i;

    I2CM    = 1;                //I2C Master mode
    address = address & 0xFE;   //Write

    if( begin( address ) ) 
    {
        stop();
        return 1;
    }   //Error - no Ack

    if( send_byte( addr ) ) 
    {
        stop();
        return 1;
    }

    for( i = 0; i < len; i++,block++)
    {
        ch = *block;
        if( send_byte( ch ) )
        { 
            stop(); 
            return 1;
        }   //Not to the end of the block
    }

    stop();

    return 0;
}

/**----------------------------------------------------------------------------
                        receive_block16()
-------------------------------------------------------------------------------
Получение блока данных от i2c-устройства с 16-разрядным внутренним адресным 
пространством. Принятый блок помещается в область памяти __xdata.

Вход:       uchar address - I2C-адрес устройства;
            ushort addr - адрес во внутреннем адресном пространстве устройства;
            uchar *block - адрес в области __xdata, куда будет помещен принятый
                блок данных;
            ushort len - длина принимаемого блока.

Выход:      нет
Результат:  0 - успешно;
            1 - устройство не откликается.
----------------------------------------------------------------------------- */
__bit receive_block16(unsigned char address, unsigned short addr, unsigned char __xdata * block,unsigned short len)
{ //addr - address in target
unsigned char ch;
unsigned short i;

    I2CM     = 1;       // I2C Master mode
    address &= 0xFE;    // Write

    if( begin(address) )
    {
        stop();     
        return 1;
    } // Error - No ACK

    if( send_byte( ( unsigned char )( addr >> 8) ) )
    {
        stop(); 
        return 1;
    }

    if( send_byte( ( unsigned char )addr ) )
    {
        stop(); 
        return 1;
    }

    delay();
    delay();

    address |= 1; //Read

    if( begin( address ) ) 
    {
        stop();
        return 1;
    }

    delay();

    if( len - 1 )
    {
        for( i = 0; i < ( len - 1 ); ++i )
        {
            ch = recv_byte();
            ack();

            *block++ = ch;
        }
    }

    ch = recv_byte();

    nack();

    *block = ch;

    stop();

    return 0;
}

/**----------------------------------------------------------------------------
                        SendBlock16()
-------------------------------------------------------------------------------
Запись блока данных во внутреннюю память i2c-устройства с 16-разрядным адресным 
пространством. 

Вход:       uchar address - I2C-адрес устройства;
            ushort addr - адрес во внутреннем адресном пространстве устройства,
                куда будет помещен блок;
            uchar *block - адрес в области __xdata, где располагаются данные для 
                пересылки;
            ushort len - длина записываемого блока.

Выход:      нет
Результат:  0 - успешно;
            1 - устройство не откликается.
----------------------------------------------------------------------------- */
__bit transmit_block16(unsigned char address, unsigned short addr, unsigned char __xdata * block,unsigned short len)
{ //addr - address in target
unsigned char ch;
unsigned short i;

    I2CM     = 1;    // I2C Master mode
    address &= 0xFE; // Write

    if( begin( address ) ) 
    {
        stop(); 
        return 1;

    } // Error - no Ack

    if( send_byte( ( unsigned char )( addr >> 8) ) ) 
    {
        stop(); 
        return 1;
    }

    if( send_byte( ( unsigned char )addr ) ) 
    {
        stop(); 
        return 1;
    }

    for( i = 0; i < len; i++, block++ )
    {
        ch = *block;

        if( send_byte( ch ) ) 
        {
            stop(); 
            return 1;
        } // Not to the end of the block
    }

    stop();

    return 0;
}
